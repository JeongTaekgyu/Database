## 1. 트랜잭션

### 트랜잭션의 정의

트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 

또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.

<br>

데이터베이스의 상태를 변화시킨다는 것은 무얼 의미하는 것일까?

간단하게 말해서 아래의 질의어(SQL)를 이용하여 데이터베이스를 접근 하는 것을 의미한다.

- SELECT
- INSERT
- DELETE
- UPDATE

착각하지 말아야 할 것은, 작업의 단위는 질의어 한문장이 아니라는 점이다.

작업단위는 많은 질의어 명령문들을 사람이 정하는 기준에 따라 정하는 것을 의미한다.

<br>

### 트랜잭션의 특징

트랜잭션의 특징은 크게 4가지로 구분된다. 

- 원자성 (Atomicity)
- 일관성 (Consistency)
- 독립성 (Isolation)
- 지속성 (Durability)

**원자성**은 트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다는 것이다.  

트랜잭션은 사람이 설계한 논리적인 작업 단위로서, 일처리는 작업단위 별로 이루어 져야 사람이 다루는데 무리가 없다.

만약 트랜잭션 단위로 데이터가 처리되지 않는다면, 설계한 사람은 데이터 처리 시스템을 이해하기 힘들 뿐만 아니라, 오작동 했을시 원인을 찾기가 매우 힘들어질것이다.

**일관성**은 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것이다. 

트랜잭션이 진행되는 동안에 데이터베이스가 변경 되더라도 업데이트된 데이터베이스로 트랜잭션이 진행되는것이 아니라,

처음에 트랜잭션을 진행 하기 위해 참조한 데이터베이스로 진행된다. 이렇게 함으로써 각 사용자는 일관성 있는 데이터를 볼 수 있는 것이다.

**독립성**은 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 경우에 어느 하나의 트랜잭션이라도 다른 트랜잭션의 연산을 끼어들 수 없다. 

하나의 특정 트랜잭션이 완료될때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.

**지속성**은 트랜잭션이 성공적으로 완료됬을 경우, 결과는 영구적으로 반영되어야 한다는 점이다.

<br>

## 2. 뮤텍스(mutex)

뮤텍스란 **MUT**ual **EX**clusion 으로 우리말로 해석하면 '상호 배제'라고 한다.
Critical Section을 가진 Thread들의 running time이 서로 겹치지 않게, 각각 단독으로 실행되게 하는 기술이다.
 \* Critical Section : 프로그램 상에서 동시에 실행될 경우 문제를 일으킬 수 있는 부분.

만약 어느 Thread에서 Critical Section을 실행하고 있으면 다른 Thread들은 그 Critical Section에 접근할 수 없고 앞의 Thread 가 Critical Section을 벗어나기를 기다려야 한다.

<br>

<br>

## 3. 임계 영역과 크리티컬 섹션

**임계 영역(Critical Section)과 크리티컬 섹션(임계 영역)**

-임계 영역과 크리티컬 섹션은 똑같은 말이다. 같은 말을 두번 반복한 이유는 하나의 표현이 두 가지 의미로 사용되기 때문이다.

<br>

**1. 임계 영역(Critical Section)**

-원래 임계 영역이란 둘 이상의 쓰레드가 동시에 실행될 경우 생길 수 있는 동시 접근 문제를 발생시킬 수 있는 코드 블록을 임계 영역이라고 한다.

-동시 접근 문제가 발생한 메모리 공간(힙, 데이터 영역)을 임계 영역이라고 하는 게 아니라, 동시 접근 문제가 발생할 수 있는 우리가 짠 코드 블록을 임계영역이라고 한다.

```java
LONG gTotalCount = 0;
 
void IncreaseCount() //쓰레드가 호출하는 함수
{
  gTotalCount++; //여기가 임계 영역(Critical Section)
}
```

-임계 영역에 대한 정의를 있어보이는 말로 표현하면, 임계 영역(Critical Section)이란 배타적 접근(한 순간에 하나의 쓰레드만 접근)이 요구되는 공유 리소스(힙, 데이터 영역에 할당된 값)에 접근하는 코드 블록을 의미한다.

<br>

**2. 크리티컬 섹션**

-크리티컬 섹션이란 위에서 설명한 임계 영역에 대한 문제를 해결하기 위한 동기화 기법을 의미한다.

-마이크로소프트에서 Critical Section(원래의 임계 영역)에 대한 동기화 기법을 똑같이 Critical Section이라고 이름을 지어서 헷갈릴 수 있다.

-특정 임계 영역에 대한 키(크리티컬 섹션 오브젝트)를 가져야만 임계 영역에 접근하도록 하는 것이다. 

-자료형은 CRITICAL_SECTION이고, 다음과 같이 선언할 수 있다.

```java
CRITICAL_SECTION gCriticalSection; //크리티컬 섹션 오브젝트
```

<br>

-InitializeCriticalSection함수를 통해서 초기화해주어야 한다.

```java
void InitializeCriticalSection(
  LPCRITICAL_SECTION lpCriticalSection
);
```

1)lpCriticalSection : 초기화하고자 하는 크리티컬 섹션 오브젝트의 주소값

<br>

-EnterCriticalSection 함수는 임계 영역에 진입(Enter)하게 해주는 함수이다. 이미 이 함수를 다른 쓰레드가 호출하여 해당 임계 영역에 진입하였다면, 뒤늦게 진입하려는 쓰레드는 호출된 함수가 블로킹되어 기다리게 된다. EnterCriticalSection함수를 호출해 진입에 성공하게 되면 크리티컬 섹션 오브젝트를 획득했다고 표현한다. 

```java
void EnterCriticalSection(
  LPCRITICAL_SECTION lpCriticalSection
);
```

<br>

-LeaveCriticalSection함수는 임계영역을 빠져나오고 호출하는 함수이다. 크리티컬 섹션 오브젝트를 획득해서 임계 영역에 진입한 쓰레드가 크리티컬 섹션을 반환하기 위해 호출하는 것이다. 이로써 블로킹에 빠졌던 쓰레드는 해당 임계 영역에 진입할 수 있게 된다. 

```java
void LeaveCriticalSection(
  LPCRITICAL_SECTION lpCriticalSection
);
```

<br>

-InitializeCriticalSection의 초기화를 통해 할당된 리소스들을 반환하기 위해 DeleteCriticalSection을 호출한다.

```java
void DeleteCriticalSection(
  LPCRITICAL_SECTION lpCriticalSection
);
```

<br><br>

## 4. 스핀락

Spin Lock 은 이름이 뜻하는대로, 만약 다른 스레드가 lock을 소유하고 있다면 그 lock이 반환될 때까지 계속 확인하며 기다리는 것이다. "조금만 기다리면 바로 쓸 수 있는데 굳이 컨텍스트 스위칭으로 부하를 줄 필요가 있나?" 라는 컨셉으로 개발된 것으로 크리티컬 섹션에 진입이 불가능할때 컨텍스트 스위칭을 하지 않고 잠시 루프를 돌면서 재시도 하는 것을 말합니다. Lock-Unlcok 과정이 아주 짧아서 락하는 경우가 드문 경우(즉; 적절하게 크리티컬 섹션을 사용한 경우) 유용하다. Spin Lock 은 다음과 같은 특성을 갖는다.

( **Context switching : **멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)를 **교체하는 작업**을 Context Switch(Context Switching)라고 한다. )

1. Lock을 얻을 수 없다면, 계속해서 Lock을 확인하며 얻을 때까지 기다린다. 이른바 바쁘게 기다리는 busy wating이다.
2. 바쁘게 기다린다는 것은 무한 루프를 돌면서 최대한 다른 스레드에게 CPU를 양보하지 않는 것이다.
3. Lock이 곧 사용가능해질 경우 컨택스트 스위치를 줄여 CPU의 부담을 덜어준다. 하지만, 만약 어떤 스레드가 Lock을 오랫동안 유지한다면 오히려 CPU 시간을 많이 소모할 가능성이 있다.
4.  하나의 CPU나 하나의 코어만 있는 경우에는 유용하지 않다. 그 이유는 만약 다른 스레드가 Lock을 가지고 있고 그 스레드가 Lock을 풀어 주려면 싱글 CPU 시스템에서는 어차피 컨택스트 스위치가 일어나야 하기 때문이다. 주의할 점 스핀락을 잘못 사용하면 CPU 사용률 100%를 만드는 상황이 발생하므로 주의 해야 한다. 스핀락은 기본적으로 무한 for 루프를 돌면서 lock을 기다리므로 하나의 쓰레드가 lock을 오랫동안 가지고 있다면, 다른 blocking된 쓰레드는 busy waiting을 하므로 CPU를 쓸데없이 낭비하게 된다.

장점은 스핀락을 잘 사용하면 context switch를 줄여 효율을 높일 수 있습니다. 무한 루프를 돌기 보다는 일정 시간 lock을 얻을 수 없다면 잠시 sleep하는 back off 알고리즘을 사용하는 것이 훨씬 좋습니다.